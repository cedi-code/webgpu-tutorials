<!DOCTYPE html>
<html>
    <head>
        <title>Hello WebGPU</title>
        <meta charset="utf-8">
    </head>
    <body>
        <canvas></canvas>
        <script type="module">
            async function main() {

                const adapter = await navigator.gpu?.requestAdapter();
                const device = await adapter?.requestDevice();
                if(!device) {
                    alert("browser needs WebGPU support");
                    return;
                }

                // get webgpu context from canvas
                const canvas = document.querySelector('canvas');
                const context = canvas.getContext('webgpu');
                const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                context.configure({
                    device,
                    format: presentationFormat,
                });

                const module = device.createShaderModule({
                    label: 'red triangle',
                    code:  /* wgsl */ `
                    @vertex fn vs(
                        @builtin(vertex_index) vertexIndex : u32
                    ) -> @builtin(position) vec4f {
                        let pos = array(
                            vec2f(0.0, 0.5), // top
                            vec2f(-0.5, -0.5), // left
                            vec2f(0.5, -0.5) // right
                        );

                        return vec4f(pos[vertexIndex], 0.0, 1.0);
                    }

                    @fragment fn fs() -> @location(0) vec4f {
                        return vec4f(1.0, 0.0, 0.0, 1.0);
                    }
                    `,
                });

                const pipeline = device.createRenderPipeline({
                    label: 'red triangle',
                    layout: 'auto',
                    vertex: {
                        entryPoint: 'vs',
                        module,
                    },
                    fragment: {
                        entryPoint: 'fs',
                        module,
                        targets: [{ format: presentationFormat }],
                    }
                });

                const renderPassDescriptor = {
                    label: 'basic renderpass',
                    colorAttachments: [
                        {
                            clearValue: [0.3, 0.3, 0.3, 1.0],
                            loadOp: 'clear',
                            storeOp: 'store',
                        },
                    ],
                };

                function render() {

                    // get current textrure from canvas
                    renderPassDescriptor.colorAttachments[0].view = context.getCurrentTexture().createView();

                    const encoder = device.createCommandEncoder({ label: 'my first encoder'});

                    // make a render pass
                    const pass = encoder.beginRenderPass(renderPassDescriptor);
                    pass.setPipeline(pipeline);
                    pass.draw(3);
                    pass.end();

                    const commandBuffer = encoder.finish();
                    device.queue.submit([commandBuffer]);
                }

                render();

                // COMPUTE SHADER

                const moduleCompute = device.createShaderModule({
                    label: 'doubling compute module',
                    code: /* wgsl */ `
                        @group(0) @binding(0) var<storage, read_write> data: array<f32>;
                        
                        @compute @workgroup_size(1) fn computeSomething(
                            @builtin(global_invocation_id) id: vec3u
                        ) {
                            let i = id.x;
                            data[i] = data[i] * 2.0;
                        }
                    
                    `,
                });

                const pipelineCompute = device.createComputePipeline({
                    label: 'doubling compute pipeline',
                    layout: 'auto',
                    compute: {
                        module: moduleCompute,
                        entryPoint: 'computeSomething',
                    },
                });

                const input = new Float32Array([1, 3, 5]);

                // create buffer
                // input and output
                const workBuffer = device.createBuffer({
                    label: 'work buffer',
                    size: input.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
                });

                device.queue.writeBuffer(workBuffer, 0, input);

                const resultBuffer = device.createBuffer({
                    label: 'result buffer',
                    size: input.byteLength,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                });

                // bind group 
                const bindGroup = device.createBindGroup({
                    label: 'bindGroup for work buffer',
                    layout: pipelineCompute.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: workBuffer } },
                    ],
                });

                // encode commands
                const encoder = device.createCommandEncoder({
                    label: 'doubling encoder',
                });
                const passCompute = encoder.beginComputePass({
                    label: 'doubling compute pass',
                });
                passCompute.setPipeline(pipelineCompute);
                passCompute.setBindGroup(0, bindGroup);
                passCompute.dispatchWorkgroups(input.length);
                passCompute.end();

                encoder.copyBufferToBuffer(workBuffer, 0, resultBuffer, 0, resultBuffer.size);

                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);

                await resultBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(resultBuffer.getMappedRange());

                console.log('input:', input);
                console.log('result:', result);

                resultBuffer.unmap();

            }
            main();
        </script>
    </body>

</html>